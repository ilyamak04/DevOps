`Аргументы сборки (ARG)` не сохраняются в конечном образе. ARG используется для передачи значений на этапе сборки. Эти значения доступны только во время сборки образа и не сохраняются в конечном образе. Также ARG не сохраняется в слоях образа, т.е. с помощью `docker history` значение переменной не посмотреть. Нельзя получить доступ к значению ARG из финального образа. 

--- 
Про ВОЛЮМЫ

Например, есть такой волюм

`./infrastructure/db/create_db.sql:/docker-entrypoint-initdb.d/create_db.sql`

если `./infrastructure/db/create_db.sql` не будет на хосте, Docker создаст директории с указанными именами вместо файлов

--- 

Как докер ищет образы? 

- Докер сначала проверяет есть ли образ с указанным именем и тегом локально на хосте (в кэше Docker)
- Если образ не найден локально, докер ищет его в registry по умолчанию, то есть в Dockerhub, Docker пытается спуллить образ с докер хаб, если тэг не указан, Docker использует тег `latest` по умолчанию
- Дальше Docker идет в настроенный Docker registry и ищет образ там, например

`image: registry.example.com/myimage:tag`

- Если образ не найден и в docker-compose.yml указана секция build, Docker создаст образ локально из Dockerfile, который находится в указанной директории. Пример в docker-compose.yml:
```yaml
services:
  myapp:
    build:
      context: .
      dockerfile: Dockerfile
```

Последовательность

1. Ищет локально на хосте.
2. Ищет на Docker Hub.
3. Ищет в частных реестрах (если указан).
4. Сборка из Dockerfile (если указана опция build в docker-compose.yml).

---
Когда мы пишем 
```yaml
depends_on:
  postgresql-db:
    condition: service_healthy
```

это значит что все хелфчеки к сервису (контейнеру) postgresql-db должны выполниться успешно, только после этого контейнер начнёт подниматься

--- 
Оператор `&&` в командах оболочки используется для цепочки команд, где следующая команда выполняется только если предыдущая выполнилась успешно (с кодом возврата 0).

---
CMD [] не использует оболочку для выполнения команды, команда передаётся напрямую процессу, то есть пайпы и всяки приблуды оболочки не работают
Docker не запускает оболочку, а передает команду напрямую в процесс. 

--- 
В чём разница сежду ENTRYPOINT и CMD

CMD можно переопределить при запуске контейнера
```
docker run <image> echo Hello
```

ENTRYPOINT задает команду, которая всегда будет выполняться при запуске контейнера. Он используется для установки основной команды, которая должна быть выполнена, и она не может быть легко перезаписана при запуске контейнера. Однако, вы можете передавать дополнительные параметры командой docker run, и эти параметры будут добавлены к командной строке, указанной в ENTRYPOINT. В отличие от CMD, ENTRYPOINT гарантирует, что указанная команда будет выполнена, даже если при запуске контейнера вы не укажете команду.

в ENTRYPOINT можно передавать переменные окружения
```
ENV MY_VAR=Hello
ENTRYPOINT ["sh", "-c", "echo $MY_VAR"]
```

```
ENTRYPOINT ["nginx", "-g"]
CMD ["daemon off;"]
```

--- 
```
key: |
  Первая строка
  Вторая строка
  Третья строка
```
Результат
```
Первая строка
Вторая строка
Третья строка
```

```
key: >
  Первая строка
  Вторая строка
  Третья строка
```
Результат
```
Первая строка Вторая строка Третья строка
```
```
key: >
  Первая строка
  Вторая строка
```
Результат
```
Первая строка Вторая строка\n
```
```
key: >-
  Первая строка
  Вторая строка
```
Результат
```
Первая строка Вторая строка
```